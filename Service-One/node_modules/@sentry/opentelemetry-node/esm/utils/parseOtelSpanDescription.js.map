{"version":3,"file":"parseOtelSpanDescription.js","sources":["../../../src/utils/parseOtelSpanDescription.ts"],"sourcesContent":["import type { AttributeValue, Attributes } from '@opentelemetry/api';\nimport { SpanKind } from '@opentelemetry/api';\nimport type { Span as OtelSpan } from '@opentelemetry/sdk-trace-base';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport type { TransactionSource } from '@sentry/types';\nimport { getSanitizedUrlString, parseUrl, stripUrlQueryAndFragment } from '@sentry/utils';\n\ninterface SpanDescription {\n  op: string | undefined;\n  description: string;\n  source: TransactionSource;\n  data?: Record<string, string>;\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n *\n * @param otelSpan\n * @returns Better op/description to use, or undefined\n */\nexport function parseOtelSpanDescription(otelSpan: OtelSpan): SpanDescription {\n  const { attributes, name } = otelSpan;\n\n  // if http.method exists, this is an http request span\n  //\n  // TODO: Referencing `http.request.method` is a temporary workaround until the semantic\n  // conventions export an attribute key for it.\n  const httpMethod = attributes['http.request.method'] || attributes[SemanticAttributes.HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod(otelSpan, httpMethod);\n  }\n\n  // If db.type exists then this is a database call span.\n  const dbSystem = attributes[SemanticAttributes.DB_SYSTEM];\n  if (dbSystem) {\n    return descriptionForDbSystem(otelSpan, dbSystem);\n  }\n\n  // If rpc.service exists then this is a rpc call span.\n  const rpcService = attributes[SemanticAttributes.RPC_SERVICE];\n  if (rpcService) {\n    return {\n      op: 'rpc',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  const messagingSystem = attributes[SemanticAttributes.MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      op: 'message',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  const faasTrigger = attributes[SemanticAttributes.FAAS_TRIGGER];\n  if (faasTrigger) {\n    return { op: faasTrigger.toString(), description: name, source: 'route' };\n  }\n\n  return { op: undefined, description: name, source: 'custom' };\n}\n\nfunction descriptionForDbSystem(otelSpan: OtelSpan, _dbSystem: AttributeValue): SpanDescription {\n  const { attributes, name } = otelSpan;\n\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  const statement = attributes[SemanticAttributes.DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\nfunction descriptionForHttpMethod(otelSpan: OtelSpan, httpMethod: AttributeValue): SpanDescription {\n  const { name, kind, attributes } = otelSpan;\n\n  const opParts = ['http'];\n\n  switch (kind) {\n    case SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  const httpRoute = attributes[SemanticAttributes.HTTP_ROUTE];\n  const { urlPath, url, query, fragment } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { op: opParts.join('.'), description: name, source: 'custom' };\n  }\n\n  // Ex. description=\"GET /api/users\".\n  const description = `${httpMethod} ${urlPath}`;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const source: TransactionSource = httpRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data: Record<string, string> = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\n/** Exported for tests only */\nexport function getSanitizedUrl(\n  attributes: Attributes,\n  kind: SpanKind,\n): {\n  url: string | undefined;\n  urlPath: string | undefined;\n  query: string | undefined;\n  fragment: string | undefined;\n} {\n  // This is the relative path of the URL, e.g. /sub\n  const httpTarget = attributes[SemanticAttributes.HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  const httpUrl = attributes[SemanticAttributes.HTTP_URL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[SemanticAttributes.HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl && parsedUrl.search ? parsedUrl.search : undefined;\n  const fragment = parsedUrl && parsedUrl.hash ? parsedUrl.hash : undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment };\n  }\n\n  if (kind === SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: stripUrlQueryAndFragment(httpTarget), url, query, fragment };\n  }\n\n  return { urlPath: undefined, url, query, fragment };\n}\n"],"names":[],"mappings":"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"}