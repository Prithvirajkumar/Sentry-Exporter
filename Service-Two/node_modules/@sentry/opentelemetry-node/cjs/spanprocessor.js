var {
  _optionalChain
} = require('@sentry/utils');

Object.defineProperty(exports, '__esModule', { value: true });

const api = require('@opentelemetry/api');
const core$1 = require('@opentelemetry/core');
const core = require('@sentry/core');
const utils = require('@sentry/utils');
const constants = require('./constants.js');
const debugBuild = require('./debug-build.js');
const captureExceptionForTimedEvent = require('./utils/captureExceptionForTimedEvent.js');
const isSentryRequest = require('./utils/isSentryRequest.js');
const mapOtelStatus = require('./utils/mapOtelStatus.js');
const parseOtelSpanDescription = require('./utils/parseOtelSpanDescription.js');
const spanMap = require('./utils/spanMap.js');

/**
 * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via
 * the Sentry SDK.
 */
class SentrySpanProcessor  {
   constructor() {
    core.addTracingExtensions();

    core.addEventProcessor(event => {
      const otelSpan = api.trace && api.trace.getActiveSpan && (api.trace.getActiveSpan() );
      if (!otelSpan) {
        return event;
      }

      const otelSpanContext = otelSpan.spanContext();

      // If event has already set `trace` context, use that one.
      event.contexts = {
        trace: {
          trace_id: otelSpanContext.traceId,
          span_id: otelSpanContext.spanId,
          parent_span_id: otelSpan.parentSpanId,
        },
        ...event.contexts,
      };

      return event;
    });
  }

  /**
   * @inheritDoc
   */
   onStart(otelSpan, parentContext) {
    const otelSpanId = otelSpan.spanContext().spanId;
    const otelParentSpanId = otelSpan.parentSpanId;

    // Otel supports having multiple non-nested spans at the same time
    // so we cannot use hub.getSpan(), as we cannot rely on this being on the current span
    const sentryParentSpan = otelParentSpanId && spanMap.getSentrySpan(otelParentSpanId);

    if (sentryParentSpan) {
      // eslint-disable-next-line deprecation/deprecation
      const sentryChildSpan = sentryParentSpan.startChild({
        description: otelSpan.name,
        instrumenter: 'otel',
        startTimestamp: convertOtelTimeToSeconds(otelSpan.startTime),
        spanId: otelSpanId,
      });

      spanMap.setSentrySpan(otelSpanId, sentryChildSpan);
    } else {
      const traceCtx = getTraceData(otelSpan, parentContext);
      // eslint-disable-next-line deprecation/deprecation
      const transaction = core.getCurrentHub().startTransaction({
        name: otelSpan.name,
        ...traceCtx,
        attributes: otelSpan.attributes,
        instrumenter: 'otel',
        startTimestamp: convertOtelTimeToSeconds(otelSpan.startTime),
        spanId: otelSpanId,
      });

      spanMap.setSentrySpan(otelSpanId, transaction);
    }
  }

  /**
   * @inheritDoc
   */
   onEnd(otelSpan) {
    const otelSpanId = otelSpan.spanContext().spanId;
    const sentrySpan = spanMap.getSentrySpan(otelSpanId);

    if (!sentrySpan) {
      debugBuild.DEBUG_BUILD && utils.logger.error(`SentrySpanProcessor could not find span with OTEL-spanId ${otelSpanId} to finish.`);
      spanMap.clearSpan(otelSpanId);
      return;
    }

    // Auto-instrumentation often captures outgoing HTTP requests
    // This means that Sentry HTTP requests created by this integration can, in turn, be captured by OTEL auto instrumentation,
    // leading to an infinite loop.
    // In this case, we do not want to finish the span, in order to avoid sending it to Sentry
    if (isSentryRequest.isSentryRequestSpan(otelSpan)) {
      spanMap.clearSpan(otelSpanId);
      return;
    }

    const client = core.getClient();

    const mutableOptions = { drop: false };
    client && client.emit && _optionalChain([client, 'optionalAccess', _ => _.emit, 'call', _2 => _2('otelSpanEnd', otelSpan, mutableOptions)]);

    if (mutableOptions.drop) {
      spanMap.clearSpan(otelSpanId);
      return;
    }

    // eslint-disable-next-line deprecation/deprecation
    const hub = core.getCurrentHub();
    otelSpan.events.forEach(event => {
      captureExceptionForTimedEvent.maybeCaptureExceptionForTimedEvent(hub, event, otelSpan);
    });

    if (sentrySpan instanceof core.Transaction) {
      updateTransactionWithOtelData(sentrySpan, otelSpan);
      sentrySpan.setHub(hub);
    } else {
      updateSpanWithOtelData(sentrySpan, otelSpan);
    }

    // Ensure we do not capture any OTEL spans for finishing (and sending) this
    api.context.with(core$1.suppressTracing(api.context.active()), () => {
      sentrySpan.end(convertOtelTimeToSeconds(otelSpan.endTime));
    });

    spanMap.clearSpan(otelSpanId);
  }

  /**
   * @inheritDoc
   */
   shutdown() {
    return Promise.resolve();
  }

  /**
   * @inheritDoc
   */
   async forceFlush() {
    const client = core.getClient();
    if (client) {
      return client.flush().then();
    }
    return Promise.resolve();
  }
}

function getTraceData(otelSpan, parentContext) {
  const spanContext = otelSpan.spanContext();
  const traceId = spanContext.traceId;
  const spanId = spanContext.spanId;

  const parentSpanId = otelSpan.parentSpanId;
  const traceparentData = parentContext.getValue(constants.SENTRY_TRACE_PARENT_CONTEXT_KEY) ;
  const dynamicSamplingContext = parentContext.getValue(constants.SENTRY_DYNAMIC_SAMPLING_CONTEXT_KEY)

;

  const context = {
    spanId,
    traceId,
    parentSpanId,
    metadata: {
      // only set dynamic sampling context if sentry-trace header was set
      dynamicSamplingContext: traceparentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,
      source: 'custom',
    },
  };

  // Only inherit sample rate if `traceId` is the same
  if (traceparentData && traceId === traceparentData.traceId) {
    context.parentSampled = traceparentData.parentSampled;
  }

  return context;
}

function updateSpanWithOtelData(sentrySpan, otelSpan) {
  const { attributes, kind } = otelSpan;

  const { op, description, data } = parseOtelSpanDescription.parseOtelSpanDescription(otelSpan);

  sentrySpan.setStatus(mapOtelStatus.mapOtelStatus(otelSpan));

  const allData = {
    ...attributes,
    ...data,
    'otel.kind': api.SpanKind[kind],
  };
  sentrySpan.setAttributes(allData);

  sentrySpan.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);
  sentrySpan.updateName(description);
}

function updateTransactionWithOtelData(transaction, otelSpan) {
  const { op, description, source, data } = parseOtelSpanDescription.parseOtelSpanDescription(otelSpan);

  // eslint-disable-next-line deprecation/deprecation
  transaction.setContext('otel', {
    attributes: otelSpan.attributes,
    resource: otelSpan.resource.attributes,
  });

  const allData = data || {};
  transaction.setAttributes(allData);

  transaction.setStatus(mapOtelStatus.mapOtelStatus(otelSpan));

  transaction.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);
  transaction.updateName(description);
  transaction.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, source);
}

function convertOtelTimeToSeconds([seconds, nano]) {
  return seconds + nano / 1000000000;
}

exports.SentrySpanProcessor = SentrySpanProcessor;
//# sourceMappingURL=spanprocessor.js.map
